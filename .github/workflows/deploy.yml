name: deploy
on:
  push:
    branches: [develop, main]
  workflow_dispatch: {}

jobs:
  deploy:
    runs-on: ubuntu-latest
    permissions:
      id-token: write
      contents: read
    environment: ${{ github.ref_name == 'main' && 'prod' || 'dev' }}

    steps:
      - uses: actions/checkout@v4

      - uses: actions/setup-node@v4
        with: { node-version: 20 }

      - name: Enable pnpm
        run: corepack enable

      - name: Configure AWS credentials (OIDC)
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_ROLE_ARN }}
          aws-region: ${{ vars.AWS_REGION }}

      - name: Resolve AWS identity
        id: aws
        run: |
          echo "account_id=$(aws sts get-caller-identity --query Account --output text)" >> $GITHUB_OUTPUT

      - name: Derive environment flags
        id: derive
        run: |
          APP_NAME="${{ vars.APP_NAME }}"
          if [ "${GITHUB_REF_NAME}" = "main" ]; then
            echo "env_name=prod" >> $GITHUB_OUTPUT
            echo "node_env=production" >> $GITHUB_OUTPUT
            echo "stack_id=${APP_NAME}-prod" >> $GITHUB_OUTPUT
            echo "log_level=info" >> $GITHUB_OUTPUT
            echo "ecr_repo=${APP_NAME}-prod" >> $GITHUB_OUTPUT
          else
            echo "env_name=dev" >> $GITHUB_OUTPUT
            echo "node_env=development" >> $GITHUB_OUTPUT
            echo "stack_id=${APP_NAME}-dev" >> $GITHUB_OUTPUT
            echo "log_level=debug" >> $GITHUB_OUTPUT
            echo "ecr_repo=" >> $GITHUB_OUTPUT
          fi

      - name: Compose env for deploy
        run: |
          mkdir -p infra
          cat > infra/.env.deploy <<EOF
          PORT=${{ vars.PORT || 8080 }}
          NODE_ENV=${{ steps.derive.outputs.node_env }}
          LOG_LEVEL=${{ steps.derive.outputs.log_level }}

          ARGON2_MEMORY_COST=${{ vars.ARGON2_MEMORY_COST || 2048 }}
          ARGON2_TIME_COST=${{ vars.ARGON2_TIME_COST || 10 }}
          ARGON2_PARALLELISM=${{ vars.ARGON2_PARALLELISM || 1 }}

          CERBOS_HOST=${{ vars.CERBOS_HOST || 'cerbos' }}
          CERBOS_PORT=${{ vars.CERBOS_PORT || 3592 }}
          CERBOS_TLS=${{ vars.CERBOS_TLS || 'false' }}
          CERBOS_PLAYGROUND_INSTANCE=${{ vars.CERBOS_PLAYGROUND_INSTANCE || '' }}
          CERBOS_ADMIN_USERNAME=${{ vars.CERBOS_ADMIN_USERNAME || 'cerbos' }}

          AWS_REGION=${{ vars.AWS_REGION }}
          URL=${{ vars.URL || (github.ref_name == 'main' && 'https://api.example.com' || 'http://localhost:3000') }}

          REDIS_HOST=${{ vars.REDIS_HOST || 'redis' }}
          REDIS_PORT=${{ vars.REDIS_PORT || 6379 }}

          DB_HOST=${{ vars.DB_HOST || 'postgres' }}
          DB_PORT=${{ vars.DB_PORT || 5432 }}
          DB_USER=${{ vars.DB_USER || 'postgres' }}
          DB_NAME=${{ vars.DB_NAME || 'app' }}
          DB_SYNCHRONIZE=${{ vars.DB_SYNCHRONIZE || 'false' }}
          DB_LOGGING=${{ vars.DB_LOGGING || 'false' }}
          DB_TYPE=postgres
          DB_POOL_MAX=${{ vars.DB_POOL_MAX || (github.ref_name == 'main' && 50 || 20) }}
          DB_POOL_MIN=${{ vars.DB_POOL_MIN || (github.ref_name == 'main' && 2 || 1) }}
          DB_POOL_IDLE_TIMEOUT=${{ vars.DB_POOL_IDLE_TIMEOUT || 30000 }}
          DB_POOL_ACQUIRE_TIMEOUT=${{ vars.DB_POOL_ACQUIRE_TIMEOUT || 60000 }}
          DB_POOL_REAP_INTERVAL=${{ vars.DB_POOL_REAP_INTERVAL || 1000 }}
          DB_POOL_CREATE_TIMEOUT=${{ vars.DB_POOL_CREATE_TIMEOUT || 30000 }}
          DB_POOL_CREATE_RETRY_INTERVAL=${{ vars.DB_POOL_CREATE_RETRY_INTERVAL || 200 }}
          DB_RETRY_ATTEMPTS=${{ vars.DB_RETRY_ATTEMPTS || 5 }}
          DB_RETRY_DELAY=${{ vars.DB_RETRY_DELAY || 3000 }}
          EOF
          echo "JWT_SECRET=${{ secrets.JWT_SECRET }}" >> infra/.env.deploy
          echo "JWT_REFRESH_SECRET=${{ secrets.JWT_REFRESH_SECRET }}" >> infra/.env.deploy
          echo "AT_API_KEY=${{ secrets.AT_API_KEY }}" >> infra/.env.deploy
          echo "CERBOS_ADMIN_PASSWORD=${{ secrets.CERBOS_ADMIN_PASSWORD }}" >> infra/.env.deploy
          echo "REDIS_PASSWORD=${{ secrets.REDIS_PASSWORD }}" >> infra/.env.deploy

      - name: Install infra deps
        working-directory: infra
        run: |
          pnpm i
          pnpm build

      - name: CDK bootstrap
        working-directory: infra
        env:
          ACCOUNT_ID: ${{ steps.aws.outputs.account_id }}
        run: pnpm dlx cdk bootstrap aws://$ACCOUNT_ID/${{ vars.AWS_REGION }}

      - name: Ensure ECR (prod only)
        if: ${{ steps.derive.outputs.env_name == 'prod' }}
        run: |
          aws ecr describe-repositories --repository-names "${{ steps.derive.outputs.ecr_repo }}" >/dev/null 2>&1 || \
          aws ecr create-repository --repository-name "${{ steps.derive.outputs.ecr_repo }}" >/dev/null

      - name: Login to ECR (prod only)
        if: ${{ steps.derive.outputs.env_name == 'prod' }}
        uses: aws-actions/amazon-ecr-login@v2

      - name: Build & push image (prod only)
        if: ${{ steps.derive.outputs.env_name == 'prod' }}
        env:
          ACCOUNT_ID: ${{ steps.aws.outputs.account_id }}
        run: |
          REGISTRY="$ACCOUNT_ID.dkr.ecr.${{ vars.AWS_REGION }}.amazonaws.com"
          IMAGE_TAG="${{ github.sha }}"
          docker build -t $REGISTRY/${{ steps.derive.outputs.ecr_repo }}:$IMAGE_TAG .
          docker push $REGISTRY/${{ steps.derive.outputs.ecr_repo }}:$IMAGE_TAG

      - name: Deploy
        working-directory: infra
        env:
          ENV_FILE: infra/.env.deploy
        run: |
          if [ "${{ steps.derive.outputs.env_name }}" = "prod" ]; then
            pnpm cdk deploy ${{ steps.derive.outputs.stack_id }} \
              -c ecrRepositoryName=${{ steps.derive.outputs.ecr_repo }} \
              -c imageTag=${{ github.sha }} \
              --require-approval never
          else
            pnpm cdk deploy ${{ steps.derive.outputs.stack_id }} --require-approval never
          fi
